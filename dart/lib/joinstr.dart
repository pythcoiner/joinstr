// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Coinjoin over nostr
class Joinstr {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Joinstr(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Joinstr.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  Pools list_pools(
    int back,
    int timeout,
    ffi.Pointer<ffi.Char> relay,
  ) {
    return _list_pools(
      back,
      timeout,
      relay,
    );
  }

  late final _list_poolsPtr = _lookup<
      ffi.NativeFunction<
          Pools Function(
              ffi.Uint64, ffi.Uint64, ffi.Pointer<ffi.Char>)>>('list_pools');
  late final _list_pools = _list_poolsPtr
      .asFunction<Pools Function(int, int, ffi.Pointer<ffi.Char>)>();

  Coins list_coins(
    ffi.Pointer<ffi.Char> mnemonics,
    ffi.Pointer<ffi.Char> addr,
    int port,
    Network network,
    int index_min,
    int index_max,
  ) {
    return _list_coins(
      mnemonics,
      addr,
      port,
      network.value,
      index_min,
      index_max,
    );
  }

  late final _list_coinsPtr = _lookup<
      ffi.NativeFunction<
          Coins Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint16,
              ffi.UnsignedInt,
              ffi.Uint32,
              ffi.Uint32)>>('list_coins');
  late final _list_coins = _list_coinsPtr.asFunction<
      Coins Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int, int, int)>();

  Txid initiate_coinjoin(
    PoolConfig config,
    PeerConfig peer,
  ) {
    return _initiate_coinjoin(
      config,
      peer,
    );
  }

  late final _initiate_coinjoinPtr =
      _lookup<ffi.NativeFunction<Txid Function(PoolConfig, PeerConfig)>>(
          'initiate_coinjoin');
  late final _initiate_coinjoin =
      _initiate_coinjoinPtr.asFunction<Txid Function(PoolConfig, PeerConfig)>();

  Txid join_coinjoin(
    ffi.Pointer<ffi.Char> pool,
    PeerConfig peer,
  ) {
    return _join_coinjoin(
      pool,
      peer,
    );
  }

  late final _join_coinjoinPtr = _lookup<
          ffi.NativeFunction<Txid Function(ffi.Pointer<ffi.Char>, PeerConfig)>>(
      'join_coinjoin');
  late final _join_coinjoin = _join_coinjoinPtr
      .asFunction<Txid Function(ffi.Pointer<ffi.Char>, PeerConfig)>();
}

enum Error {
  None(0),
  Tokio(1),
  CastString(2),
  Json(3),
  CString(4),
  ListPools(5),
  ListCoins(6),
  InitiateConjoin(7),
  SerdeJson(8),
  PoolConfig(9),
  PeerConfig(10);

  final int value;
  const Error(this.value);

  static Error fromValue(int value) => switch (value) {
        0 => None,
        1 => Tokio,
        2 => CastString,
        3 => Json,
        4 => CString,
        5 => ListPools,
        6 => ListCoins,
        7 => InitiateConjoin,
        8 => SerdeJson,
        9 => PoolConfig,
        10 => PeerConfig,
        _ => throw ArgumentError("Unknown value for Error: $value"),
      };
}

enum Network {
  /// Mainnet Bitcoin.
  Bitcoin(0),

  /// Bitcoin's testnet network.
  Testnet(1),

  /// Bitcoin's signet network.
  Signet(2),

  /// Bitcoin's regtest network.
  Regtest(3);

  final int value;
  const Network(this.value);

  static Network fromValue(int value) => switch (value) {
        0 => Bitcoin,
        1 => Testnet,
        2 => Signet,
        3 => Regtest,
        _ => throw ArgumentError("Unknown value for Network: $value"),
      };
}

final class Pools extends ffi.Struct {
  external ffi.Pointer<ffi.Char> pools;

  @ffi.UnsignedInt()
  external int errorAsInt;

  Error get error => Error.fromValue(errorAsInt);
}

final class Coins extends ffi.Struct {
  external ffi.Pointer<ffi.Char> coins;

  @ffi.UnsignedInt()
  external int errorAsInt;

  Error get error => Error.fromValue(errorAsInt);
}

final class Txid extends ffi.Struct {
  external ffi.Pointer<ffi.Char> txid;

  @ffi.UnsignedInt()
  external int errorAsInt;

  Error get error => Error.fromValue(errorAsInt);
}

final class PoolConfig extends ffi.Struct {
  @ffi.Double()
  external double denomination;

  @ffi.Uint32()
  external int fee;

  @ffi.Uint64()
  external int max_duration;

  @ffi.Uint8()
  external int peers;

  @ffi.UnsignedInt()
  external int networkAsInt;

  Network get network => Network.fromValue(networkAsInt);
}

final class PeerConfig extends ffi.Struct {
  external ffi.Pointer<ffi.Char> electrum_address;

  @ffi.Uint16()
  external int electrum_port;

  external ffi.Pointer<ffi.Char> mnemonics;

  external ffi.Pointer<ffi.Char> input;

  external ffi.Pointer<ffi.Char> output;

  external ffi.Pointer<ffi.Char> relay;
}
